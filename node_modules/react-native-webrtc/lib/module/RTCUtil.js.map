{"version":3,"sources":["RTCUtil.ts"],"names":["DEFAULT_AUDIO_CONSTRAINTS","DEFAULT_VIDEO_CONSTRAINTS","facingMode","frameRate","height","width","FACING_MODES","ASPECT_RATIO","STANDARD_OFFER_OPTIONS","icerestart","offertoreceiveaudio","offertoreceivevideo","voiceactivitydetection","SDP_TYPES","getDefaultMediaConstraints","mediaType","TypeError","extractString","constraints","prop","value","type","v","extractNumber","Number","parseInt","normalizeMediaConstraints","c","deviceId","includes","Math","round","chr4","random","toString","slice","uniqueID","deepClone","obj","JSON","parse","stringify","isSdpTypeValid","normalizeOfferOptions","options","newOptions","key","Object","entries","newKey","toLowerCase","String","Boolean","normalizeConstraints","mediaTypeConstraints","typeofMediaTypeConstraints"],"mappings":"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","sourcesContent":["\nconst DEFAULT_AUDIO_CONSTRAINTS = {};\n\nconst DEFAULT_VIDEO_CONSTRAINTS = {\n    facingMode: 'user',\n    frameRate: 30,\n    height: 720,\n    width: 1280\n};\n\nconst FACING_MODES = [ 'user', 'environment' ];\n\nconst ASPECT_RATIO = 16 / 9;\n\nconst STANDARD_OFFER_OPTIONS = {\n    icerestart: 'IceRestart',\n    offertoreceiveaudio: 'OfferToReceiveAudio',\n    offertoreceivevideo: 'OfferToReceiveVideo',\n    voiceactivitydetection: 'VoiceActivityDetection'\n};\n\nconst SDP_TYPES = [\n    'offer',\n    'pranswer',\n    'answer',\n    'rollback'\n];\n\nfunction getDefaultMediaConstraints(mediaType) {\n    switch (mediaType) {\n        case 'audio':\n            return DEFAULT_AUDIO_CONSTRAINTS;\n        case 'video':\n            return DEFAULT_VIDEO_CONSTRAINTS;\n        default:\n            throw new TypeError(`Invalid media type: ${mediaType}`);\n    }\n}\n\nfunction extractString(constraints, prop) {\n    const value = constraints[prop];\n    const type = typeof value;\n\n    if (type === 'object') {\n        for (const v of [ 'exact', 'ideal' ]) {\n            if (value[v]) {\n                return value[v];\n            }\n        }\n    } else if (type === 'string') {\n        return value;\n    }\n}\n\nfunction extractNumber(constraints, prop) {\n    const value = constraints[prop];\n    const type = typeof value;\n\n    if (type === 'number') {\n        return Number.parseInt(value);\n    } else if (type === 'object') {\n        for (const v of [ 'exact', 'ideal', 'max', 'min' ]) {\n            if (value[v]) {\n                return Number.parseInt(value[v]);\n            }\n        }\n    }\n}\n\nfunction normalizeMediaConstraints(constraints, mediaType) {\n    switch (mediaType) {\n        case 'audio':\n            return constraints;\n\n        case 'video': {\n            const c = {\n                deviceId: extractString(constraints, 'deviceId'),\n                facingMode: extractString(constraints, 'facingMode'),\n                frameRate: extractNumber(constraints, 'frameRate'),\n                height: extractNumber(constraints, 'height'),\n                width: extractNumber(constraints, 'width')\n            };\n\n            if (!c.deviceId) {\n                delete c.deviceId;\n            }\n\n            if (!FACING_MODES.includes(c.facingMode)) {\n                c.facingMode = DEFAULT_VIDEO_CONSTRAINTS.facingMode;\n            }\n\n            if (!c.frameRate) {\n                c.frameRate = DEFAULT_VIDEO_CONSTRAINTS.frameRate;\n            }\n\n            if (!c.height && !c.width) {\n                c.height = DEFAULT_VIDEO_CONSTRAINTS.height;\n                c.width = DEFAULT_VIDEO_CONSTRAINTS.width;\n            } else if (!c.height && c.width) {\n                c.height = Math.round(c.width / ASPECT_RATIO);\n            } else if (!c.width && c.height) {\n                c.width = Math.round(c.height * ASPECT_RATIO);\n            }\n\n            return c;\n        }\n\n        default:\n            throw new TypeError(`Invalid media type: ${mediaType}`);\n    }\n}\n\n/**\n * Utility for creating short random strings from float point values.\n * We take 4 characters from the end after converting to a string.\n * Conversion to string gives us some letters as we don't want just numbers.\n * Should be suitable to pass for enough randomness.\n *\n * @return {String} 4 random characters\n */\nfunction chr4() {\n    return Math.random().toString(16).slice(-4);\n}\n\n/**\n * Put together a random string in UUIDv4 format {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\n *\n * @return {String} uuidv4\n */\nexport function uniqueID(): string {\n    return `${chr4()}${chr4()}-${chr4()}-${chr4()}-${chr4()}-${chr4()}${chr4()}${chr4()}`;\n}\n\n/**\n * Utility for deep cloning an object. Object.assign() only does a shallow copy.\n *\n * @param {Object} obj - object to be cloned\n * @return {Object} cloned obj\n */\nexport function deepClone<T>(obj: T): T {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Checks whether an SDP type is valid or not.\n *\n * @param type SDP type to check.\n * @returns Whether the SDP type is valid or not.\n */\nexport function isSdpTypeValid(type: string): boolean {\n    return SDP_TYPES.includes(type);\n}\n\n/**\n * Normalize options passed to createOffer().\n *\n * @param options - user supplied options\n * @return Normalized options\n */\nexport function normalizeOfferOptions(options: object = {}): object {\n    const newOptions = {};\n\n    if (!options) {\n        return newOptions;\n    }\n\n    // Convert standard options into WebRTC internal constant names.\n    // See: https://github.com/jitsi/webrtc/blob/0cd6ce4de669bed94ba47b88cb71b9be0341bb81/sdk/media_constraints.cc#L113\n    for (const [ key, value ] of Object.entries(options)) {\n        const newKey = STANDARD_OFFER_OPTIONS[key.toLowerCase()];\n\n        if (newKey) {\n            newOptions[newKey] = String(Boolean(value));\n        }\n    }\n\n    return newOptions;\n}\n\n/**\n * Normalize the given constraints in something we can work with.\n */\nexport function normalizeConstraints(constraints) {\n    const c = deepClone(constraints);\n\n    for (const mediaType of [ 'audio', 'video' ]) {\n        const mediaTypeConstraints = c[mediaType];\n        const typeofMediaTypeConstraints = typeof mediaTypeConstraints;\n\n        if (typeofMediaTypeConstraints !== 'undefined') {\n            if (typeofMediaTypeConstraints === 'boolean') {\n                if (mediaTypeConstraints) {\n                    c[mediaType] = getDefaultMediaConstraints(mediaType);\n                }\n            } else if (typeofMediaTypeConstraints === 'object') {\n                c[mediaType] = normalizeMediaConstraints(mediaTypeConstraints, mediaType);\n            } else {\n                throw new TypeError(`constraints.${mediaType} is neither a boolean nor a dictionary`);\n            }\n        }\n    }\n\n    return c;\n}\n"]}